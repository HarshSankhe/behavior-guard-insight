const axios = require('axios');
const RiskLog = require('../models/RiskLog');
const Session = require('../models/Session');
const Alert = require('../models/Alert');

const ML_SERVICE_URL = process.env.ML_SERVICE_URL || 'http://localhost:8001';
const ML_API_KEY = process.env.ML_API_KEY || 'dev-ml-api-key-123';

async function processRiskScore(userId, sessionId, events, io) {
  try {
    console.log(`üß† Processing risk score for user ${userId}, session ${sessionId}`);
    
    // Call ML service for inference
    const mlResponse = await axios.post(`${ML_SERVICE_URL}/infer`, {
      user_id: userId,
      session_id: sessionId,
      events: events
    }, {
      headers: {
        'X-ML-API-KEY': ML_API_KEY,
        'Content-Type': 'application/json'
      },
      timeout: 10000
    });

    const { riskScore, factors, timestamp, details } = mlResponse.data;

    // Save risk log
    const riskLog = new RiskLog({
      userId,
      sessionId,
      riskScore,
      factors: {
        typingSpeed: {
          value: factors.typingSpeed?.value || 0,
          deviation: factors.typingSpeed?.deviation || "Normal"
        },
        mouseSpeed: {
          value: factors.mouseSpeed?.value || 0,
          deviation: factors.mouseSpeed?.deviation || "Normal"
        },
        latency: {
          value: factors.latency?.value || 0,
          deviation: factors.latency?.deviation || "Normal"
        },
        appUsage: {
          value: factors.appUsage?.value || 0,
          deviation: factors.appUsage?.deviation || "Normal"
        },
        overall: {
          confidence: details.confidence || 0.5,
          anomalies: details.anomalies || []
        }
      },
      modelUsed: details.modelUsed || 'global',
      reconstructionError: details.reconstructionError || 0,
      eventCount: events.length,
      timestamp: new Date(timestamp)
    });

    await riskLog.save();

    // Update session with latest risk score
    await Session.findOneAndUpdate(
      { sessionId, userId },
      { 
        $set: {
          'riskScore.current': riskScore,
          lastActivity: new Date()
        },
        $max: {
          'riskScore.max': riskScore
        }
      }
    );

    // Create alert if risk is high
    if (riskScore >= 70) {
      const alert = new Alert({
        userId,
        sessionId,
        type: riskScore >= 90 ? 'Suspicious Activity' : 'Anomaly Detected',
        severity: riskScore >= 90 ? 'Critical' : 'High',
        description: `Risk score elevated to ${riskScore}%`,
        details: {
          riskScore,
          factors: {
            typingSpeed: factors.typingSpeed?.deviation || "Normal",
            mouseSpeed: factors.mouseSpeed?.deviation || "Normal", 
            latency: factors.latency?.deviation || "Normal",
            appUsage: factors.appUsage?.deviation || "Normal"
          },
          recommendations: generateRecommendations(factors),
          autoGenerated: true
        }
      });
      
      await alert.save();
      
      // Emit alert via WebSocket
      io.to(`session-${sessionId}`).emit('new-alert', {
        alert,
        riskScore,
        timestamp: new Date().toISOString()
      });
    }

    // Emit risk update via WebSocket
    io.to(`session-${sessionId}`).emit('risk-update', {
      riskScore,
      factors,
      timestamp,
      sessionId
    });

    console.log(`‚úÖ Risk score processed: ${riskScore}% for session ${sessionId}`);
    
  } catch (error) {
    console.error('‚ùå Risk processing error:', error);
    
    // Fallback - save minimal risk log
    try {
      const fallbackRisk = new RiskLog({
        userId,
        sessionId,
        riskScore: 50, // Default neutral score
        factors: {},
        modelUsed: 'fallback',
        reconstructionError: 0,
        eventCount: events.length
      });
      await fallbackRisk.save();
    } catch (fallbackError) {
      console.error('‚ùå Fallback risk save error:', fallbackError);
    }
  }
}

function generateRecommendations(factors) {
  const recommendations = [];
  
  if (factors.typingSpeed?.deviation === 'High') {
    recommendations.push('Consider secondary authentication for unusual typing patterns');
  }
  
  if (factors.mouseSpeed?.deviation === 'High') {
    recommendations.push('Verify user identity due to abnormal mouse behavior');
  }
  
  if (factors.latency?.deviation === 'High') {
    recommendations.push('Check for potential network security issues');
  }
  
  if (factors.appUsage?.deviation === 'High') {
    recommendations.push('Review application access patterns for anomalies');
  }
  
  if (recommendations.length === 0) {
    recommendations.push('Monitor session closely and consider manual review');
  }
  
  return recommendations;
}

module.exports = {
  processRiskScore
};